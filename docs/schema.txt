-- ============================================================================
-- HIDDEN SPOTS V1 BACKEND - SUPABASE SETUP
-- ============================================================================

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";
CREATE EXTENSION IF NOT EXISTS postgis;

-- ============================================================================
-- 1. USER PROFILES TABLE
-- ============================================================================
CREATE TABLE public.profiles (
    id UUID REFERENCES auth.users(id) ON DELETE CASCADE PRIMARY KEY,
    email TEXT,
    display_name TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Subscription info
    subscription_status TEXT DEFAULT 'free' CHECK (subscription_status IN ('free', 'pro', 'trial')),
    subscription_expires_at TIMESTAMP WITH TIME ZONE,
    trial_used BOOLEAN DEFAULT FALSE,
    
    -- Stats
    spots_added INTEGER DEFAULT 0,
    spots_visited INTEGER DEFAULT 0,
    spots_bookmarked INTEGER DEFAULT 0,
    
    -- Preferences
    preferred_radius INTEGER DEFAULT 5, -- miles
    notification_enabled BOOLEAN DEFAULT TRUE
);

-- Auto-create profile on user signup
CREATE OR REPLACE FUNCTION public.handle_new_user()
RETURNS TRIGGER AS $$
BEGIN
    INSERT INTO public.profiles (id, email, display_name, subscription_status, subscription_expires_at, trial_used)
    VALUES (
        NEW.id,
        NEW.email,
        COALESCE(NEW.raw_user_meta_data->>'display_name', split_part(NEW.email, '@', 1)),
        'trial',
        NOW() + INTERVAL '7 days',
        FALSE
    );
    RETURN NEW;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

CREATE TRIGGER on_auth_user_created
    AFTER INSERT ON auth.users
    FOR EACH ROW EXECUTE FUNCTION public.handle_new_user();

-- ============================================================================
-- 2. SPOTS TABLE
-- ============================================================================
CREATE TABLE public.spots (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Basic info
    title TEXT NOT NULL,
    description TEXT,
    category TEXT NOT NULL CHECK (category IN ('quiet', 'nature', 'art', 'views')),
    
    -- Location
    latitude DOUBLE PRECISION NOT NULL,
    longitude DOUBLE PRECISION NOT NULL,
    location GEOGRAPHY(POINT, 4326) GENERATED ALWAYS AS (ST_Point(longitude, latitude)::geography) STORED,
    address TEXT,
    city TEXT DEFAULT 'Philadelphia',
    
    -- Media
    image_url TEXT,
    image_urls TEXT[], -- For future multiple images
    
    -- User & moderation
    created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
    status TEXT DEFAULT 'published' CHECK (status IN ('published', 'pending', 'rejected', 'archived')),
    rejection_reason TEXT,
    
    -- Engagement stats
    view_count INTEGER DEFAULT 0,
    bookmark_count INTEGER DEFAULT 0,
    visit_count INTEGER DEFAULT 0,
    
    -- Metadata
    tags TEXT[],
    is_featured BOOLEAN DEFAULT FALSE,
    featured_until TIMESTAMP WITH TIME ZONE
);

-- Indexes for performance
CREATE INDEX idx_spots_location ON spots USING GIST (location);
CREATE INDEX idx_spots_category ON spots (category);
CREATE INDEX idx_spots_status ON spots (status);
CREATE INDEX idx_spots_created_by ON spots (created_by);
CREATE INDEX idx_spots_city ON spots (city);

-- ============================================================================
-- 3. BOOKMARKS TABLE
-- ============================================================================
CREATE TABLE public.bookmarks (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    spot_id UUID REFERENCES public.spots(id) ON DELETE CASCADE NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    UNIQUE(user_id, spot_id)
);

CREATE INDEX idx_bookmarks_user_id ON bookmarks (user_id);
CREATE INDEX idx_bookmarks_spot_id ON bookmarks (spot_id);

-- ============================================================================
-- 4. VISITS TABLE
-- ============================================================================
CREATE TABLE public.visits (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE NOT NULL,
    spot_id UUID REFERENCES public.spots(id) ON DELETE CASCADE NOT NULL,
    visited_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Optional check-in data
    rating INTEGER CHECK (rating >= 1 AND rating <= 5),
    notes TEXT,
    
    UNIQUE(user_id, spot_id) -- One visit per spot per user for now
);

CREATE INDEX idx_visits_user_id ON visits (user_id);
CREATE INDEX idx_visits_spot_id ON visits (spot_id);

-- ============================================================================
-- 5. SUBSCRIPTION EVENTS TABLE (for Stripe webhooks)
-- ============================================================================
CREATE TABLE public.subscription_events (
    id UUID DEFAULT uuid_generate_v4() PRIMARY KEY,
    user_id UUID REFERENCES public.profiles(id) ON DELETE CASCADE,
    stripe_customer_id TEXT,
    stripe_subscription_id TEXT,
    event_type TEXT NOT NULL,
    status TEXT,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT NOW(),
    
    -- Store the full webhook payload for debugging
    webhook_data JSONB
);

CREATE INDEX idx_subscription_events_user_id ON subscription_events (user_id);
CREATE INDEX idx_subscription_events_stripe_customer ON subscription_events (stripe_customer_id);

-- ============================================================================
-- 6. ROW LEVEL SECURITY (RLS) POLICIES
-- ============================================================================

-- Enable RLS on all tables
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.spots ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.bookmarks ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.visits ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.subscription_events ENABLE ROW LEVEL SECURITY;

-- Profiles: Users can only see/edit their own profile
CREATE POLICY "Users can view own profile" ON public.profiles
    FOR SELECT USING (auth.uid() = id);

CREATE POLICY "Users can update own profile" ON public.profiles
    FOR UPDATE USING (auth.uid() = id);

-- Spots: Everyone can view published spots, only owners can edit their spots
CREATE POLICY "Anyone can view published spots" ON public.spots
    FOR SELECT USING (status = 'published');

CREATE POLICY "Users can insert spots" ON public.spots
    FOR INSERT WITH CHECK (auth.uid() = created_by);

CREATE POLICY "Users can update own spots" ON public.spots
    FOR UPDATE USING (auth.uid() = created_by);

-- Bookmarks: Users can only manage their own bookmarks
CREATE POLICY "Users can view own bookmarks" ON public.bookmarks
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own bookmarks" ON public.bookmarks
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can delete own bookmarks" ON public.bookmarks
    FOR DELETE USING (auth.uid() = user_id);

-- Visits: Users can only manage their own visits
CREATE POLICY "Users can view own visits" ON public.visits
    FOR SELECT USING (auth.uid() = user_id);

CREATE POLICY "Users can insert own visits" ON public.visits
    FOR INSERT WITH CHECK (auth.uid() = user_id);

CREATE POLICY "Users can update own visits" ON public.visits
    FOR UPDATE USING (auth.uid() = user_id);

-- Subscription events: Only viewable by the user (for support/debugging)
CREATE POLICY "Users can view own subscription events" ON public.subscription_events
    FOR SELECT USING (auth.uid() = user_id);

-- ============================================================================
-- 7. DATABASE FUNCTIONS
-- ============================================================================

-- Function to get spots near a location with user-specific data
CREATE OR REPLACE FUNCTION get_spots_near_location(
    user_lat DOUBLE PRECISION,
    user_lng DOUBLE PRECISION,
    radius_miles INTEGER DEFAULT 10,
    category_filter TEXT DEFAULT NULL,
    limit_count INTEGER DEFAULT 50
)
RETURNS TABLE (
    id UUID,
    title TEXT,
    description TEXT,
    category TEXT,
    latitude DOUBLE PRECISION,
    longitude DOUBLE PRECISION,
    image_url TEXT,
    created_at TIMESTAMP WITH TIME ZONE,
    distance_miles DOUBLE PRECISION,
    is_bookmarked BOOLEAN,
    is_visited BOOLEAN,
    bookmark_count INTEGER,
    visit_count INTEGER
) AS $$
BEGIN
    RETURN QUERY
    SELECT 
        s.id,
        s.title,
        s.description,
        s.category,
        s.latitude,
        s.longitude,
        s.image_url,
        s.created_at,
        ST_Distance(
            s.location,
            ST_Point(user_lng, user_lat)::geography
        ) / 1609.34 as distance_miles, -- Convert meters to miles
        EXISTS(
            SELECT 1 FROM bookmarks b 
            WHERE b.spot_id = s.id AND b.user_id = auth.uid()
        ) as is_bookmarked,
        EXISTS(
            SELECT 1 FROM visits v 
            WHERE v.spot_id = s.id AND v.user_id = auth.uid()
        ) as is_visited,
        s.bookmark_count,
        s.visit_count
    FROM spots s
    WHERE 
        s.status = 'published'
        AND ST_Distance(
            s.location,
            ST_Point(user_lng, user_lat)::geography
        ) <= radius_miles * 1609.34 -- Convert miles to meters
        AND (category_filter IS NULL OR s.category = category_filter)
    ORDER BY distance_miles
    LIMIT limit_count;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to toggle bookmark
CREATE OR REPLACE FUNCTION toggle_bookmark(spot_id_param UUID)
RETURNS BOOLEAN AS $$
DECLARE
    bookmark_exists BOOLEAN;
BEGIN
    -- Check if bookmark exists
    SELECT EXISTS(
        SELECT 1 FROM bookmarks 
        WHERE user_id = auth.uid() AND spot_id = spot_id_param
    ) INTO bookmark_exists;
    
    IF bookmark_exists THEN
        -- Remove bookmark
        DELETE FROM bookmarks 
        WHERE user_id = auth.uid() AND spot_id = spot_id_param;
        
        -- Decrement bookmark count
        UPDATE spots 
        SET bookmark_count = bookmark_count - 1 
        WHERE id = spot_id_param;
        
        -- Update user stats
        UPDATE profiles 
        SET spots_bookmarked = spots_bookmarked - 1 
        WHERE id = auth.uid();
        
        RETURN FALSE;
    ELSE
        -- Add bookmark
        INSERT INTO bookmarks (user_id, spot_id) 
        VALUES (auth.uid(), spot_id_param);
        
        -- Increment bookmark count
        UPDATE spots 
        SET bookmark_count = bookmark_count + 1 
        WHERE id = spot_id_param;
        
        -- Update user stats
        UPDATE profiles 
        SET spots_bookmarked = spots_bookmarked + 1 
        WHERE id = auth.uid();
        
        RETURN TRUE;
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to mark spot as visited
CREATE OR REPLACE FUNCTION mark_visited(spot_id_param UUID, rating_param INTEGER DEFAULT NULL, notes_param TEXT DEFAULT NULL)
RETURNS BOOLEAN AS $$
DECLARE
    already_visited BOOLEAN;
BEGIN
    -- Check if already visited
    SELECT EXISTS(
        SELECT 1 FROM visits 
        WHERE user_id = auth.uid() AND spot_id = spot_id_param
    ) INTO already_visited;
    
    IF already_visited THEN
        -- Update existing visit
        UPDATE visits 
        SET visited_at = NOW(), rating = rating_param, notes = notes_param
        WHERE user_id = auth.uid() AND spot_id = spot_id_param;
        
        RETURN FALSE; -- Not a new visit
    ELSE
        -- Add new visit
        INSERT INTO visits (user_id, spot_id, rating, notes) 
        VALUES (auth.uid(), spot_id_param, rating_param, notes_param);
        
        -- Increment visit count
        UPDATE spots 
        SET visit_count = visit_count + 1 
        WHERE id = spot_id_param;
        
        -- Update user stats
        UPDATE profiles 
        SET spots_visited = spots_visited + 1 
        WHERE id = auth.uid();
        
        RETURN TRUE; -- New visit
    END IF;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to check subscription status
CREATE OR REPLACE FUNCTION check_subscription_status(user_id_param UUID DEFAULT NULL)
RETURNS TABLE (
    is_pro BOOLEAN,
    is_trial BOOLEAN,
    expires_at TIMESTAMP WITH TIME ZONE,
    days_remaining INTEGER
) AS $$
DECLARE
    target_user_id UUID;
    profile_record RECORD;
BEGIN
    -- Use provided user_id or current auth user
    target_user_id := COALESCE(user_id_param, auth.uid());
    
    SELECT * INTO profile_record 
    FROM profiles 
    WHERE id = target_user_id;
    
    IF profile_record IS NULL THEN
        RETURN QUERY SELECT FALSE, FALSE, NULL::TIMESTAMP WITH TIME ZONE, 0;
        RETURN;
    END IF;
    
    RETURN QUERY SELECT 
        (profile_record.subscription_status = 'pro' AND 
         (profile_record.subscription_expires_at IS NULL OR profile_record.subscription_expires_at > NOW())) as is_pro,
        (profile_record.subscription_status = 'trial' AND 
         profile_record.subscription_expires_at > NOW()) as is_trial,
        profile_record.subscription_expires_at,
        CASE 
            WHEN profile_record.subscription_expires_at IS NULL THEN 999
            ELSE EXTRACT(DAY FROM profile_record.subscription_expires_at - NOW())::INTEGER
        END as days_remaining;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- Function to get "Escape Now" suggestion
CREATE OR REPLACE FUNCTION escape_now_suggestion(
    user_lat DOUBLE PRECISION,
    user_lng DOUBLE PRECISION,
    max_distance_miles INTEGER DEFAULT 2
)
RETURNS TABLE (
    id UUID,
    title TEXT,
    description TEXT,
    category TEXT,
    latitude DOUBLE PRECISION,
    longitude DOUBLE PRECISION,
    image_url TEXT,
    distance_miles DOUBLE PRECISION
) AS $$
BEGIN
    -- Only for Pro users
    IF NOT EXISTS(
        SELECT 1 FROM check_subscription_status() 
        WHERE is_pro = TRUE OR is_trial = TRUE
    ) THEN
        RAISE EXCEPTION 'Pro subscription required for Escape Now feature';
    END IF;
    
    RETURN QUERY
    SELECT 
        s.id,
        s.title,
        s.description,
        s.category,
        s.latitude,
        s.longitude,
        s.image_url,
        ST_Distance(
            s.location,
            ST_Point(user_lng, user_lat)::geography
        ) / 1609.34 as distance_miles
    FROM spots s
    WHERE 
        s.status = 'published'
        AND ST_Distance(
            s.location,
            ST_Point(user_lng, user_lat)::geography
        ) <= max_distance_miles * 1609.34
        -- Exclude spots user has already visited
        AND NOT EXISTS(
            SELECT 1 FROM visits v 
            WHERE v.spot_id = s.id AND v.user_id = auth.uid()
        )
    ORDER BY RANDOM()
    LIMIT 1;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;

-- ============================================================================
-- 8. TRIGGERS FOR MAINTAINING STATS
-- ============================================================================

-- Update spot stats when bookmarks change
CREATE OR REPLACE FUNCTION update_spot_stats_on_bookmark()
RETURNS TRIGGER AS $$
BEGIN
    IF TG_OP = 'INSERT' THEN
        UPDATE spots SET bookmark_count = bookmark_count + 1 WHERE id = NEW.spot_id;
        RETURN NEW;
    ELSIF TG_OP = 'DELETE' THEN
        UPDATE spots SET bookmark_count = bookmark_count - 1 WHERE id = OLD.spot_id;
        RETURN OLD;
    END IF;
    RETURN NULL;
END;
$$ LANGUAGE plpgsql;

-- Update user stats when spots are added
CREATE OR REPLACE FUNCTION update_user_stats_on_spot_insert()
RETURNS TRIGGER AS $$
BEGIN
    UPDATE profiles 
    SET spots_added = spots_added + 1 
    WHERE id = NEW.created_by;
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;

-- Create triggers
-- CREATE TRIGGER trigger_update_bookmark_stats
--     AFTER INSERT OR DELETE ON bookmarks
--     FOR EACH ROW EXECUTE FUNCTION update_spot_stats_on_bookmark();

CREATE TRIGGER trigger_update_user_spot_stats
    AFTER INSERT ON spots
    FOR EACH ROW EXECUTE FUNCTION update_user_stats_on_spot_insert();

-- ============================================================================
-- 9. SAMPLE DATA (for testing)
-- ============================================================================

-- Insert some sample spots (run after creating a test user)
-- INSERT INTO spots (title, description, category, latitude, longitude, image_url, created_by) VALUES
-- ('Love Park Fountain', 'Iconic fountain in center city, perfect for people watching', 'views', 39.9544, -75.1653, 'https://example.com/love-park.jpg', (SELECT id FROM profiles LIMIT 1)),
-- ('Rittenhouse Square Reading Corner', 'Quiet bench under old oak trees, great for reading', 'quiet', 39.9495, -75.1695, 'https://example.com/rittenhouse.jpg', (SELECT id FROM profiles LIMIT 1)),
-- ('Magic Gardens', 'Mosaic art installation by Isaiah Zagar', 'art', 39.9423, -75.1592, 'https://example.com/magic-gardens.jpg', (SELECT id FROM profiles LIMIT 1)),
-- ('Schuylkill River Trail', 'Peaceful walking path along the river', 'nature', 39.9459, -75.1816, 'https://example.com/schuylkill-trail.jpg', (SELECT id FROM profiles LIMIT 1));
